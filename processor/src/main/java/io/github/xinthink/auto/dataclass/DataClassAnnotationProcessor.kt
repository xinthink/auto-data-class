/**
 * Annotation processor
 *
 * Created by ywu on 2017/6/26.
 */
package io.github.xinthink.auto.dataclass

import com.google.auto.common.BasicAnnotationProcessor
import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep
import com.google.auto.service.AutoService
import com.google.common.base.Throwables
import com.google.common.collect.SetMultimap
import javax.annotation.processing.ProcessingEnvironment
import javax.annotation.processing.Processor
import javax.lang.model.element.Element
import javax.lang.model.element.ElementKind
import javax.lang.model.element.Modifier
import javax.lang.model.element.TypeElement
import kotlin.reflect.KClass


/**
 * Annotation processor for auto-data-class
 */
@Suppress("unused")
@AutoService(Processor::class)
class DataClassAnnotationProcessor : BasicAnnotationProcessor() {
    override fun initSteps(): List<ProcessingStep> = listOf(DataClassStep(processingEnv))
}

/**
 * Concrete logic processing the Data Classes
 */
private class DataClassStep(val processingEnv: ProcessingEnvironment) : ProcessingStep {
    private val typeUtils = processingEnv.typeUtils
    private val errorReporter = ErrorReporter(processingEnv)

    override fun annotations() = setOf(AutoDataClass::class.java)

    override fun process(elementsByAnnotation: SetMultimap<Class<out Annotation>, Element>): MutableSet<out Element> {
        val deferredTypes = mutableSetOf<TypeElement>()
        val annotatedElements = elementsByAnnotation[AutoDataClass::class.java]
        if (annotatedElements.isEmpty()) return deferredTypes

        annotatedElements.forEach {
            if (it is TypeElement) {
                try {
                    processType(it)
                } catch (e: AbortProcessingException) {
                    // We abandoned this type; continue with the next.
                } catch (e: MissingTypeException) {
                    // We abandoned this type, but only because we needed another type that it references and
                    // that other type was missing. It is possible that the missing type will be generated by
                    // further annotation processing, so we will try again on the next round (perhaps failing
                    // again and adding it back to the list).
                    deferredTypes.add(it)
                } catch (e: RuntimeException) {
                    // Don't propagate this exception, which will confusingly crash the compiler.
                    // Instead, report a compiler error with the stack trace.
                    val trace = Throwables.getStackTraceAsString(e)
                    errorReporter.reportError("@AutoDataClass processor threw an exception: $trace", it)

                }
            }
        }

        return deferredTypes
    }

    private fun processType(type: TypeElement) {
        val adc = type.getAnnotation(AutoDataClass::class.java)
        if (adc == null) {
            // This shouldn't happen unless the compilation environment is buggy,
            // but it has happened in the past and can crash the compiler.
            errorReporter.abortWithError("annotation processor for @AutoDataClass was invoked with a type" +
                    " that does not have that annotation; this is probably a compiler bug", type)
        }
        if (type.kind !== ElementKind.CLASS) {
            errorReporter.abortWithError("@AutoDataClass only applies to classes", type)
        }
        if (implementsAnnotation(type)) {
            errorReporter.abortWithError("@AutoDataClass may not be used to implement an annotation interface", type)
        }
        if (Modifier.ABSTRACT in type.modifiers) return  // skip abstract classes

        checkModifiersIfNested(type)
    }

    private fun getTypeMirror(c: KClass<out Any>) =
            processingEnv.elementUtils.getTypeElement(c.qualifiedName).asType()

    private fun implementsAnnotation(type: TypeElement) =
            typeUtils.isAssignable(type.asType(), getTypeMirror(Annotation::class))

    private fun checkModifiersIfNested(type: TypeElement) {
        val enclosingKind = type.enclosingElement.kind
        if (enclosingKind.isClass || enclosingKind.isInterface) {
            if (Modifier.PRIVATE in type.modifiers) {
                errorReporter.abortWithError("@AutoDataClass class must not be private", type)
            }
            if (Modifier.STATIC !in type.modifiers) {
                errorReporter.abortWithError("Nested @AutoDataClass class must be static", type)
            }
        }
    }
}
