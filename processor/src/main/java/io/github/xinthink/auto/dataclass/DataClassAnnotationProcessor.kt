/**
 * Annotation processor
 *
 * Created by ywu on 2017/6/26.
 */
package io.github.xinthink.auto.dataclass

import com.google.auto.common.BasicAnnotationProcessor
import com.google.auto.common.BasicAnnotationProcessor.ProcessingStep
import com.google.auto.common.MoreElements
import com.google.auto.common.MoreElements.getLocalAndInheritedMethods
import com.google.common.base.Throwables
import com.google.common.collect.SetMultimap
import com.squareup.kotlinpoet.KotlinFile
import java.io.File
import java.io.IOException
import java.util.logging.Logger
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.SourceVersion
import javax.lang.model.element.*
import javax.lang.model.type.TypeKind
import javax.tools.JavaFileObject

/**
 * Annotation processor for auto-data-class
 */
@Suppress("unused")
//@AutoService(Processor::class)
class DataClassAnnotationProcessor : BasicAnnotationProcessor() {
    override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latestSupported()
    override fun initSteps(): List<ProcessingStep> = listOf(DataClassStep(processingEnv))
}

/**
 * Concrete logic processing the Data Classes
 */
private class DataClassStep(val processingEnv: ProcessingEnvironment) : ProcessingStep {
    private val logger = Logger.getLogger(DataClassStep::class.qualifiedName)
    private val typeUtils = processingEnv.typeUtils
    private val elementUtils = processingEnv.elementUtils
    private val errorReporter = ErrorReporter(processingEnv)
    private var sourceLocation: File? = null

    override fun annotations() = setOf(AutoDataClass::class.java)

    override fun process(elementsByAnnotation: SetMultimap<Class<out Annotation>, Element>): MutableSet<out Element> {
        val deferredTypes = mutableSetOf<TypeElement>()
        val annotatedElements = elementsByAnnotation[AutoDataClass::class.java]
        if (annotatedElements.isEmpty()) return deferredTypes

        annotatedElements.forEach {
            if (it is TypeElement) {
                try {
                    processType(it)
                } catch (e: AbortProcessingException) {
                    // We abandoned this type; continue with the next.
                } catch (e: MissingTypeException) {
                    // We abandoned this type, but only because we needed another type that it references and
                    // that other type was missing. It is possible that the missing type will be generated by
                    // further annotation processing, so we will try again on the next round (perhaps failing
                    // again and adding it back to the list).
                    deferredTypes.add(it)
                } catch (e: RuntimeException) {
                    // Don't propagate this exception, which will confusingly crash the compiler.
                    // Instead, report a compiler error with the stack trace.
                    val trace = Throwables.getStackTraceAsString(e)
                    errorReporter.reportError("@AutoDataClass processor threw an exception: $trace", it)

                }
            }
        }

        return deferredTypes
    }

    private fun processType(type: TypeElement) {
        val adc = type.getAnnotation(AutoDataClass::class.java)
        if (adc == null) {
            // This shouldn't happen unless the compilation environment is buggy,
            // but it has happened in the past and can crash the compiler.
            errorReporter.abortWithError("annotation processor for @AutoDataClass was invoked with a type" +
                    " that does not have that annotation; this is probably a compiler bug", type)
        }
        if (type.kind !== ElementKind.CLASS) {
            errorReporter.abortWithError("@AutoDataClass only applies to classes", type)
        }
//        if (implementsAnnotation(type)) {
//            errorReporter.abortWithError("@AutoDataClass may not be used to implement an annotation interface", type)
//        }
        if (Modifier.ABSTRACT in type.modifiers) return  // skip abstract classes

        checkModifiersIfNested(type)

        val propertyMethods = propertyMethodsIn(getLocalAndInheritedMethods(type, typeUtils, elementUtils))

        generateFile(type)
    }

//    private fun getTypeMirror(c: KClass<out Any>) =
//            processingEnv.elementUtils.getTypeElement(c.qualifiedName).asType()
//
//    private fun implementsAnnotation(type: TypeElement) =
//            typeUtils.isAssignable(type.asType(), getTypeMirror(Annotation::class))

    private fun checkModifiersIfNested(type: TypeElement) {
        val enclosingKind = type.enclosingElement.kind
        if (enclosingKind.isClass || enclosingKind.isInterface) {
            if (Modifier.PRIVATE in type.modifiers) {
                errorReporter.abortWithError("@AutoDataClass class must not be private", type)
            }
            if (Modifier.STATIC !in type.modifiers) {
                errorReporter.abortWithError("Nested @AutoDataClass class must be static", type)
            }
        }
    }

    private fun propertyMethodsIn(methods: Set<ExecutableElement>?): Set<ExecutableElement> =
            when (methods) {
                null -> setOf()
                else -> methods.filter {
                    it.parameters.isEmpty() &&
                            it.returnType?.kind != TypeKind.VOID &&
                            objectMethodToOverride(it) === DefaultMethod.NONE
                }.toSet()
            }

    private fun objectMethodToOverride(method: ExecutableElement): DefaultMethod {
        val name = method.simpleName.toString()
        when (method.parameters.size) {
            0 -> {
                when {
                    name == "toString" -> return DefaultMethod.TO_STRING
                    name == "hashCode" -> return DefaultMethod.HASH_CODE
                    name == "clone" -> return DefaultMethod.CLONE
                    name == "getClass" -> return DefaultMethod.CLASS
                    name.matches(REGEX_COMPONENT_FUN) -> return DefaultMethod.COMPONENT
                }
            }
            1 -> if (name == "equals" &&
                    method.parameters[0].asType().toString() == "java.lang.Object") {
                return DefaultMethod.EQUALS
            }
        }
        return DefaultMethod.NONE
    }

    /**
     * [JavaFileObject.openWriter] always create `.java` files, in order to get the source location,
     * we create a dummy `package-info` at the root package
     */
    private fun getSourceLocation(): File {
        if (sourceLocation == null) {
            val infoFile = processingEnv.filer.createSourceFile("package-info", null)
            val out = infoFile.openWriter()
            out.write("// generated by @AutoDataClass")
            out.close()
            sourceLocation = File(infoFile.name).parentFile
        }

        return sourceLocation as File
    }

    private fun findPackage(type: TypeElement): Element = MoreElements.getPackage(type)

    private fun generateFile(type: TypeElement) {
        val pkg = findPackage(type)
        val dir = getSourceLocation()
        try {
            KotlinFile.builder("$pkg", "${type.simpleName}Ext")
                    .addFileComment("hello")
                    .build()
                    .writeTo(dir)
        } catch(e: IOException) {
            // This should really be an error, but we make it a warning in the hope of resisting Eclipse
            // bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=367599. If that bug manifests, we may get
            // invoked more than once for the same file, so ignoring the ability to overwrite it is the
            // right thing to do. If we are unable to write for some other reason, we should get a compile
            // error later because user code will have a reference to the code we were supposed to
            // generate (new AutoValue_Foo() or whatever) and that reference will be undefined.
            errorReporter.reportWarning(
                    "Could not write generated class ${type.simpleName}Ext: $e", type)
        }
    }
}

val REGEX_COMPONENT_FUN = Regex("""^component\d+$""")

// methods defined in Object or generated by kotlin
private enum class DefaultMethod {
    NONE,
    // java methods
    TO_STRING,
    EQUALS, HASH_CODE, CLONE, CLASS,
    // kotlin methods
    COMPONENT,
}
