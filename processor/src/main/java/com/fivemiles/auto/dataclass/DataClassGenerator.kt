package com.fivemiles.auto.dataclass

import com.google.auto.common.AnnotationMirrors
import com.google.auto.common.MoreElements
import com.squareup.kotlinpoet.*
import org.jetbrains.annotations.Nullable
import java.beans.Introspector
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.element.ExecutableElement
import javax.lang.model.element.TypeElement
import javax.lang.model.type.TypeKind


private const val DATA_CLASS_NAME_SUFFIX = ""
private val REGEX_COMPONENT_FUN = Regex("""^component\d+$""")

/**
 * Methods defined in Object or generated by kotlin
 */
private enum class DefaultMethod {
    NONE,
    // java methods
    TO_STRING,
    EQUALS, HASH_CODE, CLONE, CLASS,
    // kotlin methods
    COMPONENT,
}

internal val dataClassNames = mutableMapOf<TypeSpec.Builder, String>()
internal var TypeSpec.Builder.simpleName: String
    set(value) {
        dataClassNames[this] = value
    }
    get() = dataClassNames[this]!!

/**
 * Generates data class given a TypeElement
 *
 * Created by ywu on 2017/7/10.
 */
internal class DataClassGenerator(
        val processingEnv: ProcessingEnvironment,
        val errorReporter: ErrorReporter) {

    private val typeUtils = processingEnv.typeUtils
    private val elementUtils = processingEnv.elementUtils
    private val gsonTypeAdapterGenerator = GsonTypeAdapterGenerator(processingEnv, errorReporter)

    /**
     * Build a data class TypeSpec for the given TypeElement
     *
     * @param element the interface element which defines the data class
     */
    @Suppress("UNCHECKED_CAST")
    fun generate(element: TypeElement): TypeSpec {
        val getters = propertyMethodsIn(MoreElements.getLocalAndInheritedMethods(element, typeUtils, elementUtils))
        val properties = propertyNameToMethodMap(getters)
        val dataClassSimpleName = generatedClassName(element.simpleName, DATA_CLASS_NAME_SUFFIX)
        val dataClassName = element.asClassName().peerClass(dataClassSimpleName)
        val builder = TypeSpec.classBuilder(dataClassName)
                .apply { this.simpleName = dataClassSimpleName }  // record the generated class name, for retrieval later
                .addSuperinterface(element.asClassName())
                .addModifiers(KModifier.DATA, KModifier.INTERNAL)
                .apply {
                    // add stuff with properties
                    val constructorBuilder = FunSpec.constructorBuilder()
                    properties.forEach {
                        val propName = it.key
                        val propType = propertyType(it.value)

                        // default value
                        val ctorParamBuilder = ParameterSpec.builder(propName, propType)
                        val propDefMirror = MoreElements.getAnnotationMirror(it.value, DataClassProp::class.java).orNull()
                        if (propDefMirror != null) {
                            val defaultValue = AnnotationMirrors.getAnnotationValue(propDefMirror,
                                    DataClassProp::defaultValueLiteral.name).value as String
                            if (defaultValue.isNotBlank()) {
                                ctorParamBuilder.defaultValue("%L", defaultValue)
                            }
                        }

                        constructorBuilder.addParameter(ctorParamBuilder.build())
                        addProperty(PropertySpec.builder(propName, propType)
                                .addModifiers(KModifier.OVERRIDE)
                                .initializer(propName)
                                .build())
                    }

                    primaryConstructor(constructorBuilder.build())
                }

        // generates the Gson TypeAdapter
        gsonTypeAdapterGenerator.generate(element, properties, builder)
        return builder.build()
    }

    private fun propertyMethodsIn(methods: Set<ExecutableElement>?): Set<ExecutableElement> =
            when (methods) {
                null -> setOf()
                else -> methods.filter {
                    it.parameters.isEmpty() &&
                            it.returnType?.kind != TypeKind.VOID &&
                            objectMethodToOverride(it) === DefaultMethod.NONE
                }.toSet()
            }

    private fun objectMethodToOverride(method: ExecutableElement): DefaultMethod {
        val name = method.simpleName.toString()
        when (method.parameters.size) {
            0 -> {
                when {
                    name == "toString" -> return DefaultMethod.TO_STRING
                    name == "hashCode" -> return DefaultMethod.HASH_CODE
                    name == "clone" -> return DefaultMethod.CLONE
                    name == "getClass" -> return DefaultMethod.CLASS
                    name.matches(REGEX_COMPONENT_FUN) -> return DefaultMethod.COMPONENT
                }
            }
            1 -> if (name == "equals" &&
                    method.parameters[0].asType().toString() == "java.lang.Object") {
                return DefaultMethod.EQUALS
            }
        }
        return DefaultMethod.NONE
    }

    // TODO skip properties with default implement
    private fun propertyNameToMethodMap(
            propertyMethods: Set<ExecutableElement>): Map<String, ExecutableElement> {
        val allPrefixed = gettersAllPrefixed(propertyMethods)
        val map = mutableMapOf<String, ExecutableElement>()
        propertyMethods.forEach {
            val methodName = "${it.simpleName}"
            val name = if (allPrefixed) nameWithoutPrefix(methodName) else methodName
            val old = map.put(name, it)
            if (old != null) {
                errorReporter.reportError("More than one @$ANNOTATION_NAME property called $name", it)
            }
        }
        return map
    }

    private fun propertyType(propertyMethod: ExecutableElement): TypeName {
        val type = propertyMethod.returnType.asTypeName()
        return if (MoreElements.isAnnotationPresent(propertyMethod, Nullable::class.java)) type.asNullable() else type
    }

    private fun gettersAllPrefixed(methods: Set<ExecutableElement>) = prefixedGettersIn(methods).size == methods.size

    private fun prefixedGettersIn(methods: Iterable<ExecutableElement>): Set<ExecutableElement> {
        return methods.filter {
            val name = "${it.simpleName}"
            // `getfoo` or `isfoo` (without a capital) is a getter currently
            name.matches("""^get.+""".toRegex()) ||
                    (name.matches("""^is.+""".toRegex()) && it.returnType.kind == TypeKind.BOOLEAN)
        }.toSet()
    }

    /**
     * Returns the name of the property defined by the given getter. A getter called `getFoo()`
     * or `isFoo()` defines a property called `foo`. For consistency with JavaBeans, a
     * getter called `getHTMLPage()` defines a property called `HTMLPage`. The
     * [rule](https://docs.oracle.com/javase/8/docs/api/java/beans/Introspector.html#decapitalize-java.lang.String-) is: the name of the property is the part after `get` or `is`, with the
     * first letter lowercased *unless* the first two letters are uppercase. This works well
     * for the `HTMLPage` example, but in these more enlightened times we use `HtmlPage`
     * anyway, so the special behaviour is not useful, and of course it behaves poorly with examples like `OAuth`.
     */
    private fun nameWithoutPrefix(methodName: String): String {
        val name = when {
            methodName.startsWith("get") -> methodName.substring(3)
            methodName.startsWith("is") -> methodName.substring(2)
            else -> throw IllegalArgumentException("")
        }
        return Introspector.decapitalize(name)
    }
}
