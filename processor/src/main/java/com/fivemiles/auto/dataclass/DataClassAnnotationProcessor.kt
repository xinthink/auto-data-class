/**
 * Annotation processor
 *
 * Created by ywu on 2017/6/26.
 */
package com.fivemiles.auto.dataclass

import com.google.auto.common.AnnotationMirrors.getAnnotationValue
import com.google.auto.common.BasicAnnotationProcessor
import com.google.auto.common.MoreElements.*
import com.google.common.base.Throwables
import com.google.common.collect.SetMultimap
import com.google.gson.Gson
import com.google.gson.TypeAdapter
import com.google.gson.stream.JsonReader
import com.google.gson.stream.JsonWriter
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ClassName.Companion.asClassName
import com.squareup.kotlinpoet.TypeName.Companion.asTypeName
import org.jetbrains.annotations.Nullable
import java.beans.Introspector
import java.io.File
import java.io.IOException
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.SourceVersion
import javax.lang.model.element.*
import javax.lang.model.type.TypeKind
import javax.lang.model.type.TypeMirror


private val ANNOTATION_NAME = "@${DataClass::class.simpleName}"
private const val CLASS_NAME_PREFIX = "Auto"
private const val CLASS_NAME_SEPARATOR = "_"
private const val DATA_CLASS_NAME_SUFFIX = ""
private const val GSON_ADAPTER_CLASS_NAME_SUFFIX = "GsonTypeAdapter"
private const val QN_GSON_TOKEN_NULL = "com.google.gson.stream.JsonToken.NULL"
private val REGEX_COMPONENT_FUN = Regex("""^component\d+$""")

private fun generatedClassName(originName: Name, suffix: String = "") =
        generatedClassName("$originName", suffix)

private fun generatedClassName(originName: String, suffix: String = "") =
        "$CLASS_NAME_PREFIX$CLASS_NAME_SEPARATOR$originName${if (suffix.isEmpty()) "" else "$CLASS_NAME_SEPARATOR$suffix"}"

/**
 * Annotation processor for auto-data-class
 */
@Suppress("UNUSED")
//@AutoService(Processor::class)
class DataClassAnnotationProcessor : BasicAnnotationProcessor() {
    override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latestSupported()
    override fun initSteps(): List<ProcessingStep> = listOf(DataClassStep(processingEnv))
}

/**
 * Concrete logic processing the Data Classes
 */
private class DataClassStep(val processingEnv: ProcessingEnvironment) : BasicAnnotationProcessor.ProcessingStep {
    private val typeUtils = processingEnv.typeUtils
    private val elementUtils = processingEnv.elementUtils
    private val errorReporter = ErrorReporter(processingEnv)
    private var sourceLocation: File? = null

    override fun annotations() = setOf(DataClass::class.java)

    override fun process(elementsByAnnotation: SetMultimap<Class<out Annotation>, Element>): MutableSet<out Element> {
        val deferredTypes = mutableSetOf<TypeElement>()
        val annotatedElements = elementsByAnnotation[DataClass::class.java]
        if (annotatedElements.isEmpty()) return deferredTypes

        annotatedElements.forEach {
            if (it is TypeElement) {
                try {
                    processType(it)
                } catch (e: AbortProcessingException) {
                    // We abandoned this type; continue with the next.
                } catch (e: MissingTypeException) {
                    // We abandoned this type, but only because we needed another type that it references and
                    // that other type was missing. It is possible that the missing type will be generated by
                    // further annotation processing, so we will try again on the next round (perhaps failing
                    // again and adding it back to the list).
                    deferredTypes.add(it)
                } catch (e: RuntimeException) {
                    // Don't propagate this exception, which will confusingly crash the compiler.
                    // Instead, report a compiler error with the stack trace.
                    val trace = Throwables.getStackTraceAsString(e)
                    errorReporter.reportError("$ANNOTATION_NAME processor threw an exception: $trace", it)

                }
            }
        }

        return deferredTypes
    }

    private fun processType(type: TypeElement) {
        val adc = type.getAnnotation(DataClass::class.java)
        if (adc == null) {
            // This shouldn't happen unless the compilation environment is buggy,
            // but it has happened in the past and can crash the compiler.
            errorReporter.abortWithError("annotation processor for $ANNOTATION_NAME was invoked with a type" +
                    " that does not have that annotation; this is probably a compiler bug", type)
        }
        if (!isApplicable(type)) {
            errorReporter.abortWithError("$ANNOTATION_NAME only applies to classes", type)
        }
//        if (implementsAnnotation(type)) {
//            errorReporter.abortWithError("$ANNOTATION_NAME may not be used to implement an annotation interface", type)
//        }

        checkNested(type)

        val dataClassSpec = dataClassSpec(type)
        generateFile(type, dataClassSpec)
    }

    private fun isApplicable(type: TypeElement) = type.kind == ElementKind.INTERFACE

//    private fun getTypeMirror(c: KClass<out Any>) =
//            processingEnv.elementUtils.getTypeElement(c.qualifiedName).asType()
//
//    private fun implementsAnnotation(type: TypeElement) =
//            typeUtils.isAssignable(type.asType(), getTypeMirror(Annotation::class))

    // nested classes not supported for now
    private fun checkNested(type: TypeElement) {
        val enclosingKind = type.enclosingElement.kind
        if (enclosingKind.isClass || enclosingKind.isInterface) {
            errorReporter.abortWithError("$ANNOTATION_NAME class must not be nested", type)
        }
    }

    private fun checkModifiersIfNested(type: TypeElement) {
        val enclosingKind = type.enclosingElement.kind
        if (enclosingKind.isClass || enclosingKind.isInterface) {
            if (Modifier.PRIVATE in type.modifiers) {
                errorReporter.abortWithError("Nested ${ANNOTATION_NAME} class must not be private", type)
            }
            if (Modifier.STATIC !in type.modifiers) {
                errorReporter.abortWithError("Nested ${ANNOTATION_NAME} class must be static", type)
            }
        }
    }

    /**
     * [JavaFileObject.openWriter] always create `.java` files, in order to get the source location,
     * we create a dummy `package-info` at the root package
     */
    private fun getSourceLocation(): File {
        if (sourceLocation == null) {
            val infoFile = processingEnv.filer.createSourceFile("package-info", null)
            val out = infoFile.openWriter()
            out.write("// generated by $ANNOTATION_NAME")
            out.close()
            sourceLocation = File(infoFile.name).parentFile
        }

        return sourceLocation as File
    }

    private fun findPackage(type: TypeElement): Element = getPackage(type)

    @Suppress("UNCHECKED_CAST")
    private fun dataClassSpec(type: TypeElement): TypeSpec {
        val getters = propertyMethodsIn(getLocalAndInheritedMethods(type, typeUtils, elementUtils))
        val properties = propertyNameToMethodMap(getters)
        val dataClassName = generatedClassName(type.simpleName, DATA_CLASS_NAME_SUFFIX)
        return TypeSpec.classBuilder(dataClassName)
                .addSuperinterface(type.asClassName())
                .addModifiers(KModifier.DATA, KModifier.INTERNAL)
                .apply {
                    val constructorBuilder = FunSpec.constructorBuilder()
                    properties.forEach {
                        val propName = it.key
                        val propType = propertyType(it.value)

                        constructorBuilder.addParameter(
                                ParameterSpec.builder(propName, propType).build())
                        addProperty(PropertySpec.builder(propName, propType)
                                .addModifiers(KModifier.OVERRIDE)
                                .initializer(propName)
                                .build())
                    }

                    primaryConstructor(constructorBuilder.build())
                }
                .build()
    }

    private fun dataClassSpecDeprecated(type: TypeElement): TypeSpec {
        val clsDefMirror = getAnnotationMirror(type, DataClass::class.java).orNull()
        val clsName = getAnnotationValue(clsDefMirror, "name").value as String
        val adapterClsName = generatedClassName(clsName, DATA_CLASS_NAME_SUFFIX)

        val propsMirror = getAnnotationValue(clsDefMirror, "props").value as List<AnnotationMirror>
        if (propsMirror.isEmpty()) {
            errorReporter.abortWithError("Data class must have at least one property", type)
        }

        return TypeSpec.classBuilder(adapterClsName)
                .addModifiers(KModifier.DATA)
                .apply {
                    val constructorBuilder = FunSpec.constructorBuilder()
                    propsMirror.forEach {
                        val propName = getAnnotationValue(it, "name").value as String
                        val propType = (getAnnotationValue(it, "type").value as TypeMirror).asTypeName()

                        constructorBuilder.addParameter(
                                ParameterSpec.Companion.builder(propName, propType).build())
                        addProperty(PropertySpec.Companion.builder(propName, propType).initializer(propName).build())
                    }

                    primaryConstructor(constructorBuilder.build())
                }
                .build()
    }

    private fun gsonTypeAdapterSpec(type: TypeElement, properties: Set<VariableElement>): TypeSpec {
        val adapterClsName = generatedClassName(type.simpleName, GSON_ADAPTER_CLASS_NAME_SUFFIX)
        val superClsTypeName = ParameterizedTypeName.Companion.get(TypeAdapter::class.asClassName(), type.asClassName())

        return TypeSpec.classBuilder(adapterClsName)
                .superclass(superClsTypeName)
                .primaryConstructor(FunSpec.constructorBuilder()
                        .addParameter("gson", Gson::class)
                        .build())
                .addProperty(PropertySpec.builder("gson", Gson::class)
                        .addModifiers(KModifier.PRIVATE)
                        .initializer("gson")
                        .build())
                .addProperties(properties.map {
                    PropertySpec.Companion.builder("${it.simpleName}",
                            ParameterizedTypeName.Companion.get(TypeAdapter::class.asClassName(), it.asType().asTypeName()))
                            .addModifiers(KModifier.PRIVATE)
                            .initializer("gson.getAdapter(%T::class.java)", it)
                            .build()
                })
                .addFun(gsonReaderFunSpec(type, properties))
                .addFun(gsonWriterFunSpec(type, properties))
                .build()
    }

    private fun gsonReaderFunSpec(type: TypeElement, properties: Set<VariableElement>): FunSpec {
        val paramNameReader = "jsonReader"
        return FunSpec.builder("read")
                .addModifiers(KModifier.OVERRIDE)
                .addParameter(paramNameReader, JsonReader::class)
                .returns(type.asClassName().asNullable())
                .beginControlFlow("if ($paramNameReader == ${QN_GSON_TOKEN_NULL}")
                .addStatement("$paramNameReader.nextNull()")
                .addStatement("return null")
                .endControlFlow()
                .addStatement("\n$paramNameReader.beginObject()")

                .addStatement("$paramNameReader.endObject()\n")
                .addStatement("return ${type.simpleName}()")
                .build()
    }

    private fun gsonWriterFunSpec(type: TypeElement, properties: Set<VariableElement>): FunSpec {
        val paramNameWriter = "jsonWriter"
        val paramNameObj = "${type.simpleName}".decapitalize()
        return FunSpec.builder("write")
                .addModifiers(KModifier.OVERRIDE)
                .addParameter(paramNameWriter, JsonWriter::class)
                .addParameter(paramNameObj, type.asClassName().asNullable())
                .build()
    }

    private fun generateFile(type: TypeElement, classSpec: TypeSpec) {
        val fileName = "${classSpec.name}"
        val pkg = findPackage(type)
        val dir = getSourceLocation()
        try {
            KotlinFile.builder("$pkg", fileName)
                    .skipJavaLangImports(true)
//          .addStaticImport(JsonToken::class, "*")
                    .addFileComment("hello\n")
                    .addType(classSpec)
                    .build()
                    .writeTo(dir)
        } catch(e: IOException) {
            // This should really be an error, but we make it a warning in the hope of resisting Eclipse
            // bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=367599. If that bug manifests, we may get
            // invoked more than once for the same file, so ignoring the ability to overwrite it is the
            // right thing to do. If we are unable to write for some other reason, we should get a compile
            // error later because user code will have a reference to the code we were supposed to
            // generate (new AutoValue_Foo() or whatever) and that reference will be undefined.
            errorReporter.reportWarning(
                    "Could not write generated class $fileName: $e", type)
        }
    }

    private fun propertyMethodsIn(methods: Set<ExecutableElement>?): Set<ExecutableElement> =
            when (methods) {
                null -> setOf()
                else -> methods.filter {
                    it.parameters.isEmpty() &&
                            it.returnType?.kind != TypeKind.VOID &&
                            objectMethodToOverride(it) === DefaultMethod.NONE
                }.toSet()
            }

    private fun objectMethodToOverride(method: ExecutableElement): DefaultMethod {
        val name = method.simpleName.toString()
        when (method.parameters.size) {
            0 -> {
                when {
                    name == "toString" -> return DefaultMethod.TO_STRING
                    name == "hashCode" -> return DefaultMethod.HASH_CODE
                    name == "clone" -> return DefaultMethod.CLONE
                    name == "getClass" -> return DefaultMethod.CLASS
                    name.matches(REGEX_COMPONENT_FUN) -> return DefaultMethod.COMPONENT
                }
            }
            1 -> if (name == "equals" &&
                    method.parameters[0].asType().toString() == "java.lang.Object") {
                return DefaultMethod.EQUALS
            }
        }
        return DefaultMethod.NONE
    }

    private fun propertyNameToMethodMap(
            propertyMethods: Set<ExecutableElement>): Map<String, ExecutableElement> {
        val allPrefixed = gettersAllPrefixed(propertyMethods)
        val map = mutableMapOf<String, ExecutableElement>()
        propertyMethods.forEach {
            val methodName = "${it.simpleName}"
            val name = if (allPrefixed) nameWithoutPrefix(methodName) else methodName
            val old = map.put(name, it)
            if (old != null) {
                errorReporter.reportError("More than one @$ANNOTATION_NAME property called $name", it)
            }
        }
        return map
    }

    private fun propertyType(propertyMethod: ExecutableElement): TypeName {
        val type = propertyMethod.returnType.asTypeName()
        return if (isAnnotationPresent(propertyMethod, Nullable::class.java)) type.asNullable() else type
    }

    private fun gettersAllPrefixed(methods: Set<ExecutableElement>) = prefixedGettersIn(methods).size == methods.size

    private fun prefixedGettersIn(methods: Iterable<ExecutableElement>): Set<ExecutableElement> {
        return methods.filter {
            val name = "${it.simpleName}"
            // `getfoo` or `isfoo` (without a capital) is a getter currently
            name.matches("""^get.+""".toRegex()) ||
                    (name.matches("""^is.+""".toRegex()) && it.returnType.kind == TypeKind.BOOLEAN)
        }.toSet()
    }

    /**
     * Returns the name of the property defined by the given getter. A getter called `getFoo()`
     * or `isFoo()` defines a property called `foo`. For consistency with JavaBeans, a
     * getter called `getHTMLPage()` defines a property called `HTMLPage`. The
     * [rule](https://docs.oracle.com/javase/8/docs/api/java/beans/Introspector.html#decapitalize-java.lang.String-) is: the name of the property is the part after `get` or `is`, with the
     * first letter lowercased *unless* the first two letters are uppercase. This works well
     * for the `HTMLPage` example, but in these more enlightened times we use `HtmlPage`
     * anyway, so the special behaviour is not useful, and of course it behaves poorly with examples like `OAuth`.
     */
    private fun nameWithoutPrefix(methodName: String): String {
        val name = when {
            methodName.startsWith("get") -> methodName.substring(3)
            methodName.startsWith("is") -> methodName.substring(2)
            else -> throw IllegalArgumentException("")
        }
        return Introspector.decapitalize(name)
    }
}

/**
 * Methods defined in Object or generated by kotlin
 */
private enum class DefaultMethod {
    NONE,
    // java methods
    TO_STRING,
    EQUALS, HASH_CODE, CLONE, CLASS,
    // kotlin methods
    COMPONENT,
}
