/**
 * Annotation processor
 *
 * Created by ywu on 2017/6/26.
 */
package com.fivemiles.auto.dataclass

import com.google.auto.common.BasicAnnotationProcessor
import com.google.auto.common.MoreElements.getPackage
import com.google.common.base.Throwables
import com.google.common.collect.SetMultimap
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.TypeSpec
import java.io.File
import java.io.IOException
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.Modifier
import javax.lang.model.element.TypeElement

/**
 * Annotation processor for auto-data-class
 */
@Suppress("UNUSED")
//@AutoService(Processor::class)
class DataClassAnnotationProcessor : BasicAnnotationProcessor(), SourceLocationManager {
    override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latestSupported()

    override fun initSteps(): List<ProcessingStep> = listOf(dataClassStep, gsonTypeAdapterFactoryStep)

    private val dataClassStep: DataClassStep by lazy {
        DataClassStep(processingEnv, this)
    }
    private val gsonTypeAdapterFactoryStep: ProcessingStep by lazy {
        GsonTypeAdapterFactoryStep(processingEnv, this, dataClassStep.processedDataClasses)
    }

    private var sourceLocation: File? = null  // cached source location

    /**
     * [javax.tools.JavaFileObject.openWriter] always create `.java` files, in order to get the source location,
     * we create a dummy `package-info` at the root package
     */
    override fun getSourceLocation(): File {
        if (sourceLocation == null) {
            val infoFile = processingEnv.filer.createSourceFile("package-info", null)
            val out = infoFile.openWriter()
            out.write("// generated by ${DataClass::class.qualifiedName}")
            out.close()
            sourceLocation = File(infoFile.name).parentFile
        }

        return sourceLocation as File
    }
}

/**
 * Source location helper
 */
internal interface SourceLocationManager {
    /** Find the root directory for the generated source files */
    fun getSourceLocation(): File
}

/**
 * Base class of [BasicAnnotationProcessor.ProcessingStep], handles a single annotation by default.
 */
internal abstract class AbstractProcessingStep(
        processingEnv: ProcessingEnvironment,
        private val sourceLocationManager: SourceLocationManager
) : BasicAnnotationProcessor.ProcessingStep {
    protected val errorReporter = ErrorReporter(processingEnv)

    protected abstract val annotation: Class<out Annotation>
    protected val annotationName: String by lazy { "@${annotation.simpleName}" }

    override fun annotations() = setOf(annotation)

    override fun process(elementsByAnnotation: SetMultimap<Class<out Annotation>, Element>): MutableSet<out Element> {
        val deferredTypes = mutableSetOf<TypeElement>()
        val annotatedElements = elementsByAnnotation[annotation]
        if (annotatedElements.isEmpty()) return deferredTypes

        annotatedElements.forEach {
            if (it is TypeElement) {
                try {
                    processElement(it)
                } catch (e: AbortProcessingException) {
                    // We abandoned this type; continue with the next.
                } catch (e: MissingTypeException) {
                    // We abandoned this type, but only because we needed another type that it references and
                    // that other type was missing. It is possible that the missing type will be generated by
                    // further annotation processing, so we will try again on the next round (perhaps failing
                    // again and adding it back to the list).
                    deferredTypes.add(it)
                } catch (e: RuntimeException) {
                    // Don't propagate this exception, which will confusingly crash the compiler.
                    // Instead, report a compiler error with the stack trace.
                    val trace = Throwables.getStackTraceAsString(e)
                    errorReporter.reportError("$annotationName processor threw an exception: $trace", it)

                }
            }
        }

        return deferredTypes
    }

    protected abstract fun isApplicable(element: Element): Boolean

    private fun processElement(element: TypeElement) {
        val adc = element.getAnnotation(annotation)
        if (adc == null) {
            // This shouldn't happen unless the compilation environment is buggy,
            // but it has happened in the past and can crash the compiler.
            errorReporter.abortWithError("annotation processor for $annotationName was invoked with a type" +
                    " that does not have that annotation; this is probably a compiler bug", element)
        }
        if (!isApplicable(element)) {
            errorReporter.abortWithError("$annotationName is not applicable", element)
        }

        checkModifiersIfNested(element)
        doProcessElement(element)
    }

    protected abstract fun doProcessElement(element: TypeElement)

    private fun checkModifiersIfNested(type: TypeElement) {
        if (type.isNestedType) {
            if (Modifier.PRIVATE in type.modifiers) {
                errorReporter.abortWithError("Nested $annotationName class must not be private", type)
            }
            if (Modifier.STATIC !in type.modifiers) {
                errorReporter.abortWithError("Nested $annotationName class must be static", type)
            }
        }
    }

    private fun getSourceLocation(): File = sourceLocationManager.getSourceLocation()

    private fun findPackage(type: TypeElement): Element = getPackage(type)

    protected fun generateFile(type: TypeElement, classSpec: TypeSpec) {
        val fileName = "${classSpec.name}"
        val pkg = findPackage(type)
        val dir = getSourceLocation()
        try {
            FileSpec.builder("$pkg", fileName)
//                    .skipJavaLangImports(true)
                    .addType(classSpec)
                    .build()
                    .writeTo(dir)
        } catch(e: IOException) {
            // This should really be an error, but we make it a warning in the hope of resisting Eclipse
            // bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=367599. If that bug manifests, we may get
            // invoked more than once for the same file, so ignoring the ability to overwrite it is the
            // right thing to do. If we are unable to write for some other reason, we should get a compile
            // error later because user code will have a reference to the code we were supposed to
            // generate (new AutoValue_Foo() or whatever) and that reference will be undefined.
            errorReporter.reportWarning(
                    "Could not write generated class $fileName: $e", type)
        }
    }
}
