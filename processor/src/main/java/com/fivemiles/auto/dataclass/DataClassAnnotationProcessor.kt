/**
 * Annotation processor
 *
 * Created by ywu on 2017/6/26.
 */
package com.fivemiles.auto.dataclass

import com.google.auto.common.BasicAnnotationProcessor
import com.google.auto.common.MoreElements.getPackage
import com.google.common.base.Throwables
import com.google.common.collect.SetMultimap
import com.squareup.kotlinpoet.KotlinFile
import com.squareup.kotlinpoet.TypeSpec
import java.io.File
import java.io.IOException
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.SourceVersion
import javax.lang.model.element.*


internal val ANNOTATION_NAME = "@${DataClass::class.simpleName}"
private const val CLASS_NAME_PREFIX = "DC"
private const val CLASS_NAME_SEPARATOR = "_"


internal fun generatedClassName(originName: Name, suffix: String = "") =
        generatedClassName("$originName", suffix)

internal fun generatedClassName(originName: String, suffix: String = "") =
        "$CLASS_NAME_PREFIX$CLASS_NAME_SEPARATOR$originName${if (suffix.isEmpty()) "" else "$CLASS_NAME_SEPARATOR$suffix"}"

/**
 * Annotation processor for auto-data-class
 */
@Suppress("UNUSED")
//@AutoService(Processor::class)
class DataClassAnnotationProcessor : BasicAnnotationProcessor() {
    override fun getSupportedSourceVersion(): SourceVersion = SourceVersion.latestSupported()
    override fun initSteps(): List<ProcessingStep> = listOf(DataClassStep(processingEnv))
}

/**
 * Concrete logic processing the Data Classes
 */
private class DataClassStep(val processingEnv: ProcessingEnvironment) : BasicAnnotationProcessor.ProcessingStep {
    private val typeUtils = processingEnv.typeUtils
    private val elementUtils = processingEnv.elementUtils
    private val errorReporter = ErrorReporter(processingEnv)
    private val dataClassGenerator = DataClassGenerator(processingEnv, errorReporter)
    private var sourceLocation: File? = null

    override fun annotations() = setOf(DataClass::class.java)

    override fun process(elementsByAnnotation: SetMultimap<Class<out Annotation>, Element>): MutableSet<out Element> {
        val deferredTypes = mutableSetOf<TypeElement>()
        val annotatedElements = elementsByAnnotation[DataClass::class.java]
        if (annotatedElements.isEmpty()) return deferredTypes

        annotatedElements.forEach {
            if (it is TypeElement) {
                try {
                    processType(it)
                } catch (e: AbortProcessingException) {
                    // We abandoned this type; continue with the next.
                } catch (e: MissingTypeException) {
                    // We abandoned this type, but only because we needed another type that it references and
                    // that other type was missing. It is possible that the missing type will be generated by
                    // further annotation processing, so we will try again on the next round (perhaps failing
                    // again and adding it back to the list).
                    deferredTypes.add(it)
                } catch (e: RuntimeException) {
                    // Don't propagate this exception, which will confusingly crash the compiler.
                    // Instead, report a compiler error with the stack trace.
                    val trace = Throwables.getStackTraceAsString(e)
                    errorReporter.reportError("$ANNOTATION_NAME processor threw an exception: $trace", it)

                }
            }
        }

        return deferredTypes
    }

    private fun processType(type: TypeElement) {
        val adc = type.getAnnotation(DataClass::class.java)
        if (adc == null) {
            // This shouldn't happen unless the compilation environment is buggy,
            // but it has happened in the past and can crash the compiler.
            errorReporter.abortWithError("annotation processor for $ANNOTATION_NAME was invoked with a type" +
                    " that does not have that annotation; this is probably a compiler bug", type)
        }
        if (!isApplicable(type)) {
            errorReporter.abortWithError("$ANNOTATION_NAME only applies to classes", type)
        }
//        if (implementsAnnotation(type)) {
//            errorReporter.abortWithError("$ANNOTATION_NAME may not be used to implement an annotation interface", type)
//        }

        checkNested(type)

        val dataClassSpec = dataClassGenerator.generate(type)
        generateFile(type, dataClassSpec)
    }

    private fun isApplicable(type: TypeElement) = type.kind == ElementKind.INTERFACE

//    private fun getTypeMirror(c: KClass<out Any>) =
//            processingEnv.elementUtils.getTypeElement(c.qualifiedName).asType()
//
//    private fun implementsAnnotation(type: TypeElement) =
//            typeUtils.isAssignable(type.asType(), getTypeMirror(Annotation::class))

    // nested classes not supported for now
    private fun checkNested(type: TypeElement) {
        val enclosingKind = type.enclosingElement.kind
        if (enclosingKind.isClass || enclosingKind.isInterface) {
            errorReporter.abortWithError("$ANNOTATION_NAME class must not be nested", type)
        }
    }

    private fun checkModifiersIfNested(type: TypeElement) {
        val enclosingKind = type.enclosingElement.kind
        if (enclosingKind.isClass || enclosingKind.isInterface) {
            if (Modifier.PRIVATE in type.modifiers) {
                errorReporter.abortWithError("Nested ${ANNOTATION_NAME} class must not be private", type)
            }
            if (Modifier.STATIC !in type.modifiers) {
                errorReporter.abortWithError("Nested ${ANNOTATION_NAME} class must be static", type)
            }
        }
    }

    /**
     * [JavaFileObject.openWriter] always create `.java` files, in order to get the source location,
     * we create a dummy `package-info` at the root package
     */
    private fun getSourceLocation(): File {
        if (sourceLocation == null) {
            val infoFile = processingEnv.filer.createSourceFile("package-info", null)
            val out = infoFile.openWriter()
            out.write("// generated by $ANNOTATION_NAME")
            out.close()
            sourceLocation = File(infoFile.name).parentFile
        }

        return sourceLocation as File
    }

    private fun findPackage(type: TypeElement): Element = getPackage(type)

    private fun generateFile(type: TypeElement, classSpec: TypeSpec) {
        val fileName = "${classSpec.name}"
        val pkg = findPackage(type)
        val dir = getSourceLocation()
        try {
            KotlinFile.builder("$pkg", fileName)
                    .skipJavaLangImports(true)
//          .addStaticImport(JsonToken::class, "*")
                    .addFileComment("hello\n")
                    .addType(classSpec)
                    .build()
                    .writeTo(dir)
        } catch(e: IOException) {
            // This should really be an error, but we make it a warning in the hope of resisting Eclipse
            // bug https://bugs.eclipse.org/bugs/show_bug.cgi?id=367599. If that bug manifests, we may get
            // invoked more than once for the same file, so ignoring the ability to overwrite it is the
            // right thing to do. If we are unable to write for some other reason, we should get a compile
            // error later because user code will have a reference to the code we were supposed to
            // generate (new AutoValue_Foo() or whatever) and that reference will be undefined.
            errorReporter.reportWarning(
                    "Could not write generated class $fileName: $e", type)
        }
    }
}
